<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.6.0_14) on Thu Apr 21 02:43:56 PDT 2011 -->
<title>java.lang.invoke (Java Platform SE 7 b139)</title>
<meta name="date" content="2011-04-21">
<meta name="keywords" content="java.lang.invoke package">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="java.lang.invoke (Java Platform SE 7 b139)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div style="background-color: #EEEEEE"> <div style="padding: 6px; margin-top: 2px; margin-bottom: 6px; margin-left: 6px; margin-right: 6px; text-align: justify; font-size: 80%; font-family: Helvetica, Arial, sans-serif; font-weight: normal;"> Please note that the specifications and other information contained herein are not final and are subject to change. The information is being made available to you solely for purpose of evaluation. </div> </div>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><strong>Java&trade;&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;7</strong><br><strong>DRAFT&nbsp;ea-b139</strong></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../java/lang/instrument/package-summary.html">Prev Package</a></li>
<li><a href="../../../java/lang/management/package-summary.html">Next Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?java/lang/invoke/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;java.lang.invoke</h1>
<div class="subTitle">
<div class="block">The <code>java.lang.invoke</code> package contains dynamic language support provided directly by
 the Java core class libraries and virtual machine.</div>
</div>
<p>See:&nbsp;<a href="#package_description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="packageSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke">CallSite</a></td>
<td class="colLast">
<div class="block">A <code>CallSite</code> is a holder for a variable <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>,
 which is called its <code>target</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/invoke/ConstantCallSite.html" title="class in java.lang.invoke">ConstantCallSite</a></td>
<td class="colLast">
<div class="block">A <code>ConstantCallSite</code> is a <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> whose target is permanent, and can never be changed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></td>
<td class="colLast">
<div class="block">A method handle is a typed, directly executable reference to an underlying method,
 constructor, field, or similar low-level operation, with optional
 transformations of arguments or return values.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke">MethodHandles</a></td>
<td class="colLast">
<div class="block">This class consists exclusively of static methods that operate on or return
 method handles.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></td>
<td class="colLast">
<div class="block">A <em>lookup object</em> is a factory for creating method handles,
 when the creation requires access checking.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a></td>
<td class="colLast">
<div class="block">A method type represents the arguments and return type accepted and
 returned by a method handle, or the arguments and return type passed
 and expected  by a method handle caller.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/MutableCallSite.html" title="class in java.lang.invoke">MutableCallSite</a></td>
<td class="colLast">
<div class="block">A <code>MutableCallSite</code> is a <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> whose target variable
 behaves like an ordinary field.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../java/lang/invoke/SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a></td>
<td class="colLast">
<div class="block">
 A <code>SwitchPoint</code> is an object which can publish state transitions to other threads.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/VolatileCallSite.html" title="class in java.lang.invoke">VolatileCallSite</a></td>
<td class="colLast">
<div class="block">A <code>VolatileCallSite</code> is a <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> whose target acts like a volatile variable.</div>
</td>
</tr>
</tbody>
</table>
</li>
<li class="blockList">
<table class="packageSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation">
<caption><span>Exception Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Exception</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></td>
<td class="colLast">
<div class="block">Thrown to indicate that code has attempted to call a method handle
 via the wrong method type.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package_description">
<!--   -->
</a>
<h2 title="Package java.lang.invoke Description">Package java.lang.invoke Description</h2>
<div class="block">The <code>java.lang.invoke</code> package contains dynamic language support provided directly by
 the Java core class libraries and virtual machine.

 <p>
 Certain types in this package have special relations to dynamic
 language support in the virtual machine:
 <ul>
 <li>The class <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a> contains
 <a href="MethodHandle.html#sigpoly">signature polymorphic methods</a>
 which can be linked regardless of their type descriptor.
 Normally, method linkage requires exact matching of type descriptors.
 </li>

 <li>The JVM bytecode format supports immediate constants of
 the classes <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a> and <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>.
 </li>
 </ul>

 <h2><a name="jvm_mods"></a>Corresponding JVM bytecode format changes</h2>
 <em>The following low-level information is presented here as a preview of
 changes being made to the Java Virtual Machine specification for JSR 292.
 This information will be incorporated in a future version of the JVM specification.</em>

 <h3><a name="indyinsn"></a><code>invokedynamic</code> instruction format</h3>
 In bytecode, an <code>invokedynamic</code> instruction is formatted as five bytes.
 The first byte is the opcode 186 (hexadecimal <code>BA</code>).
 The next two bytes are a constant pool index (in the same format as for the other <code>invoke</code> instructions).
 The final two bytes are reserved for future use and required to be zero.
 The constant pool reference of an <code>invokedynamic</code> instruction is to a entry
 with tag <code>CONSTANT_InvokeDynamic</code> (decimal 18).  See below for its format.
 The entry specifies the following information:
 <ul>
 <li>a bootstrap method (a <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a> constant)</li>
 <li>the dynamic invocation name (a UTF8 string)</li>
 <li>the argument and return types of the call (encoded as a type descriptor in a UTF8 string)</li>
 <li>optionally, a sequence of additional <em>static arguments</em> to the bootstrap method (<code>ldc</code>-type constants)</li>
 </ul>
 <p>
 Each instance of an <code>invokedynamic</code> instruction is called a <em>dynamic call site</em>.
 Multiple instances of an <code>invokedynamic</code> instruction can share a single
 <code>CONSTANT_InvokeDynamic</code> entry.
 In any case, distinct call sites always have distinct linkage state.
 <p>
 A dynamic call site is originally in an unlinked state.  In this state, there is
 no target method for the call site to invoke.
 A dynamic call site is linked by means of a bootstrap method,
 as <a href="#bsm">described below</a>.

 <h3><a name="indycon"></a>constant pool entries for <code>invokedynamic</code> instructions</h3>
 If a constant pool entry has the tag <code>CONSTANT_InvokeDynamic</code> (decimal 18),
 it must contain exactly four more bytes after the tag.
 These bytes are interpreted as two 16-bit indexes, in the usual <code>u2</code> format.
 The first pair of bytes after the tag must be an index into a side table called the
 <em>bootstrap method table</em>, which is stored in the <code>BootstrapMethods</code>
 attribute as <a href="#bsmattr">described below</a>.
 The second pair of bytes must be an index to a <code>CONSTANT_NameAndType</code>.
 <p>
 The first index specifies a bootstrap method used by the associated dynamic call sites.
 The second index specifies the method name, argument types, and return type of the dynamic call site.
 The structure of such an entry is therefore analogous to a <code>CONSTANT_Methodref</code>,
 except that the bootstrap method specifier reference replaces
 the <code>CONSTANT_Class</code> reference of a <code>CONSTANT_Methodref</code> entry.

 <h3><a name="mtcon"></a>constant pool entries for <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">method types</a></h3>
 If a constant pool entry has the tag <code>CONSTANT_MethodType</code> (decimal 16),
 it must contain exactly two more bytes, which must be an index to a <code>CONSTANT_Utf8</code>
 entry which represents a method type descriptor.
 <p>
 The JVM will ensure that on first
 execution of an <code>ldc</code> instruction for this entry, a <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>
 will be created which represents the type descriptor.
 Any classes mentioned in the <code>MethodType</code> will be loaded if necessary,
 but not initialized.
 Access checking and error reporting is performed exactly as it is for
 references by <code>ldc</code> instructions to <code>CONSTANT_Class</code> constants.

 <h3><a name="mhcon"></a>constant pool entries for <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">method handles</a></h3>
 If a constant pool entry has the tag <code>CONSTANT_MethodHandle</code> (decimal 15),
 it must contain exactly three more bytes.  The first byte after the tag is a subtag
 value which must be in the range 1 through 9, and the last two must be an index to a
 <code>CONSTANT_Fieldref</code>, <code>CONSTANT_Methodref</code>, or
 <code>CONSTANT_InterfaceMethodref</code> entry which represents a field or method
 for which a method handle is to be created.
 Furthermore, the subtag value and the type of the constant index value
 must agree according to the table below.
 <p>
 The JVM will ensure that on first execution of an <code>ldc</code> instruction
 for this entry, a <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a> will be created which represents
 the field or method reference, according to the specific mode implied by the subtag.
 <p>
 As with <code>CONSTANT_Class</code> and <code>CONSTANT_MethodType</code> constants,
 the <code>Class</code> or <code>MethodType</code> object which reifies the field or method's
 type is created.  Any classes mentioned in this reification will be loaded if necessary,
 but not initialized, and access checking and error reporting performed as usual.
 <p>
 Unlike the reflective <code>Lookup</code> API, there are no security manager calls made
 when these constants are resolved.
 <p>
 The method handle itself will have a type and behavior determined by the subtag as follows:
 <code>
 <table border=1 cellpadding=5 summary="CONSTANT_MethodHandle subtypes">
 <tr><th>N</th><th>subtag name</th><th>member</th><th>MH type</th><th>bytecode behavior</th><th>lookup expression</th></tr>
 <tr><td>1</td><td>REF_getField</td><td>C.f:T</td><td>(C)T</td><td>getfield C.f:T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findGetter(java.lang.Class, java.lang.String, java.lang.Class)">findGetter(C.class,"f",T.class)</a></td></tr>
 <tr><td>2</td><td>REF_getStatic</td><td>C.f:T</td><td>(&nbsp;)T</td><td>getstatic C.f:T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter(java.lang.Class, java.lang.String, java.lang.Class)">findStaticGetter(C.class,"f",T.class)</a></td></tr>
 <tr><td>3</td><td>REF_putField</td><td>C.f:T</td><td>(C,T)void</td><td>putfield C.f:T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSetter(java.lang.Class, java.lang.String, java.lang.Class)">findSetter(C.class,"f",T.class)</a></td></tr>
 <tr><td>4</td><td>REF_putStatic</td><td>C.f:T</td><td>(T)void</td><td>putstatic C.f:T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter(java.lang.Class, java.lang.String, java.lang.Class)">findStaticSetter(C.class,"f",T.class)</a></td></tr>
 <tr><td>5</td><td>REF_invokeVirtual</td><td>C.m(A*)T</td><td>(C,A*)T</td><td>invokevirtual C.m(A*)T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual(java.lang.Class, java.lang.String, java.lang.invoke.MethodType)">findVirtual(C.class,"m",MT)</a></td></tr>
 <tr><td>6</td><td>REF_invokeStatic</td><td>C.m(A*)T</td><td>(C,A*)T</td><td>invokestatic C.m(A*)T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic(java.lang.Class, java.lang.String, java.lang.invoke.MethodType)">findStatic(C.class,"m",MT)</a></td></tr>
 <tr><td>7</td><td>REF_invokeSpecial</td><td>C.m(A*)T</td><td>(C,A*)T</td><td>invokespecial C.m(A*)T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial(java.lang.Class, java.lang.String, java.lang.invoke.MethodType, java.lang.Class)">findSpecial(C.class,"m",MT,this.class)</a></td></tr>
 <tr><td>8</td><td>REF_newInvokeSpecial</td><td>C.&lt;init&gt;(A*)void</td><td>(A*)C</td><td>new C; dup; invokespecial C.&lt;init&gt;(A*)void</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor(java.lang.Class, java.lang.invoke.MethodType)">findConstructor(C.class,MT)</a></td></tr>
 <tr><td>9</td><td>REF_invokeInterface</td><td>C.m(A*)T</td><td>(C,A*)T</td><td>invokeinterface C.m(A*)T</td>
               <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual(java.lang.Class, java.lang.String, java.lang.invoke.MethodType)">findVirtual(C.class,"m",MT)</a></td></tr>
 </table>
 </code>
 Here, the type <code>C</code> is taken from the <code>CONSTANT_Class</code> reference associated
 with the <code>CONSTANT_NameAndType</code> descriptor.
 The field name <code>f</code> or method name <code>m</code> is taken from the <code>CONSTANT_NameAndType</code>
 as is the result type <code>T</code> and (in the case of a method or constructor) the argument type sequence
 <code>A*</code>.
 <p>
 Each method handle constant has an equivalent instruction sequence called its <em>bytecode behavior</em>.
 In general, creating a method handle constant can be done in exactly the same circumstances that
 the JVM would successfully resolve the symbolic references in the bytecode behavior.
 Also, the type of a method handle constant is such that a valid <code>invokeExact</code> call
 on the method handle has exactly the same JVM stack effects as the <em>bytecode behavior</em>.
 Finally, calling a method handle constant on a valid set of arguments has exactly the same effect
 and returns the same result (if any) as the corresponding <em>bytecode behavior</em>.
 <p>
 Each method handle constant also has an equivalent reflective <em>lookup expression</em>,
 which is a query to a method in <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>MethodHandles.Lookup</code></a>.
 In the example lookup method expression given in the table above, the name <code>MT</code>
 stands for a <code>MethodType</code> built from <code>T</code> and the sequence of argument types <code>A*</code>.
 (Note that the type <code>C</code> is not prepended to the query type <code>MT</code> even if the member is non-static.)
 In the case of <code>findSpecial</code>, the name <code>this.class</code> refers to the class containing
 the bytecodes.
 <p>
 The special name <code>&lt;clinit&gt;</code> is not allowed.
 The special name <code>&lt;init&gt;</code> is not allowed except for subtag 8 as shown.
 <p>
 The JVM verifier and linker apply the same access checks and restrictions for these references as for the hypothetical
 bytecode instructions specified in the last column of the table.
 A method handle constant will successfully resolve to a method handle if the symbolic references
 of the corresponding bytecode instruction(s) would also resolve successfully.
 Otherwise, an attempt to resolve the constant will throw equivalent linkage errors.
 In particular, method handles to
 private and protected members can be created in exactly those classes for which the corresponding
 normal accesses are legal.
 <p>
 A constant may refer to a method or constructor with the <code>varargs</code>
 bit (hexadecimal <code>0x0080</code>) set in its modifier bitmask.
 The method handle constant produced for such a method behaves as if
 it were created by <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector(java.lang.Class)"><code>asVarargsCollector</code></a>.
 In other words, the constant method handle will exhibit variable arity,
 when invoked via <code>invokeGeneric</code>.
 On the other hand, its behavior with respect to <code>invokeExact</code> will be the same
 as if the <code>varargs</code> bit were not set.
 <p>
 Although the <code>CONSTANT_MethodHandle</code> and <code>CONSTANT_MethodType</code> constant types
 resolve class names, they do not force class initialization.
 Method handle constants for subtags <code>REF_getStatic</code>, <code>REF_putStatic</code>, and <code>REF_invokeStatic</code>
 may force class initialization on their first invocation, just like the corresponding bytecodes.
 <p>
 The rules of section 5.4.3 of the
 <a href="http://java.sun.com/docs/books/jvms/second_edition/html/ConstantPool.doc.html#73492">JVM Specification</a>
 apply to the resolution of <code>CONSTANT_MethodType</code>, <code>CONSTANT_MethodHandle</code>,
 and <code>CONSTANT_InvokeDynamic</code> constants,
 by the execution of <code>invokedynamic</code> and <code>ldc</code> instructions.
 (Roughly speaking, this means that every use of a constant pool entry
 must lead to the same outcome.
 If the resolution succeeds, the same object reference is produced
 by every subsequent execution of the same instruction.
 If the resolution of the constant causes an error to occur,
 the same error will be re-thrown on every subsequent attempt
 to use this particular constant.)
 <p>
 Constants created by the resolution of these constant pool types are not necessarily
 interned.  Except for <code>CONSTANT_Class</code> and <code>CONSTANT_String</code> entries,
 two distinct constant pool entries might not resolve to the same reference
 even if they contain the same symbolic reference.

 <h2><a name="bsm"></a>Bootstrap Methods</h2>
 Before the JVM can execute a dynamic call site (an <code>invokedynamic</code> instruction),
 the call site must first be <em>linked</em>.
 Linking is accomplished by calling a <em>bootstrap method</em>
 which is given the static information content of the call site,
 and which must produce a <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>method handle</code></a>
 that gives the behavior of the call site.
 <p>
 Each <code>invokedynamic</code> instruction statically specifies its own
 bootstrap method as a constant pool reference.
 The constant pool reference also specifies the call site's name and type descriptor,
 just like <code>invokevirtual</code> and the other invoke instructions.
 <p>
 Linking starts with resolving the constant pool entry for the
 bootstrap method, and resolving a <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a> object for
 the type descriptor of the dynamic call site.
 This resolution process may trigger class loading.
 It may therefore throw an error if a class fails to load.
 This error becomes the abnormal termination of the dynamic
 call site execution.
 Linkage does not trigger class initialization.
 <p>
 Next, the bootstrap method call is started, with at least four values being stacked:
 <ul>
 <li>a <code>MethodHandle</code>, the resolved bootstrap method itself </li>
 <li>a <code>MethodHandles.Lookup</code>, a lookup object on the <em>caller class</em> in which dynamic call site occurs </li>
 <li>a <code>String</code>, the method name mentioned in the call site </li>
 <li>a <code>MethodType</code>, the resolved type descriptor of the call </li>
 <li>optionally, one or more <a href="#args">additional static arguments</a> </li>
 </ul>
 The method handle is then applied to the other values as if by
 <a href="../../../java/lang/invoke/MethodHandle.html#invokeGeneric(java.lang.Object...)"><code>invokeGeneric</code></a>.
 The returned result must be a <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> (or a subclass).
 The type of the call site's target must be exactly equal to the type
 derived from the dynamic call site's type descriptor and passed to
 the bootstrap method.
 The call site then becomes permanently linked to the dynamic call site.
 <p>
 As long as each bootstrap method can be correctly invoked
 by <code>invokeGeneric</code>, its detailed type is arbitrary.
 For example, the first argument could be <code>Object</code>
 instead of <code>MethodHandles.Lookup</code>, and the return type
 could also be <code>Object</code> instead of <code>CallSite</code>.
 (Note that the types and number of the stacked arguments limit
 the legal kinds of bootstrap methods to appropriately typed
 static methods and constructors of <code>CallSite</code> subclasses.)
 <p>
 After resolution, the linkage process may fail in a variety of ways.
 All failures are reported by a <a href="../../../java/lang/BootstrapMethodError.html" title="class in java.lang"><code>BootstrapMethodError</code></a>,
 which is thrown as the abnormal termination of the dynamic call
 site execution.
 The following circumstances will cause this:
 <ul>
 <li>the index to the bootstrap method specifier is out of range </li>
 <li>the bootstrap method cannot be resolved </li>
 <li>the <code>MethodType</code> to pass to the bootstrap method cannot be resolved </li>
 <li>a static argument to the bootstrap method cannot be resolved
     (i.e., a <code>CONSTANT_Class</code>, <code>CONSTANT_MethodType</code>,
     or <code>CONSTANT_MethodHandle</code> argument cannot be linked) </li>
 <li>the bootstrap method has the wrong arity,
     causing <code>invokeGeneric</code> to throw <code>WrongMethodTypeException</code> </li>
 <li>the bootstrap method has a wrong argument or return type </li>
 <li>the bootstrap method invocation completes abnormally </li>
 <li>the result from the bootstrap invocation is not a reference to
     an object of type <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> </li>
 <li>the target of the <code>CallSite</code> does not have a target of
     the expected <code>MethodType</code> </li>
 </ul>

 <h3><a name="linktime"></a>timing of linkage</h3>
 A dynamic call site is linked just before its first execution.
 The bootstrap method call implementing the linkage occurs within
 a thread that is attempting a first execution.
 <p>
 If there are several such threads, the bootstrap method may be
 invoked in several threads concurrently.
 Therefore, bootstrap methods which access global application
 data must take the usual precautions against race conditions.
 In any case, every <code>invokedynamic</code> instruction is either
 unlinked or linked to a unique <code>CallSite</code> object.
 <p>
 In an application which requires dynamic call sites with individually
 mutable behaviors, their bootstrap methods should produce distinct
 <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a> objects, one for each linkage request.
 Alternatively, an application can link a single <code>CallSite</code> object
 to several <code>invokedynamic</code> instructions, in which case
 a change to the target method will become visible at each of
 the instructions.
 <p>
 If several threads simultaneously execute a bootstrap method for a single dynamic
 call site, the JVM must choose one <code>CallSite</code> object and install it visibly to
 all threads.  Any other bootstrap method calls are allowed to complete, but their
 results are ignored, and their dynamic call site invocations proceed with the originally
 chosen target object.

 <p style="font-size:smaller;">
 <em>Discussion:</em>
 These rules do not enable the JVM to duplicate dynamic call sites,
 or to issue &ldquo;causeless&rdquo; bootstrap method calls.
 Every dynamic call site transitions at most once from unlinked to linked,
 just before its first invocation.
 There is no way to undo the effect of a completed bootstrap method call.

 <h3><a name="bsmattr">the <code>BootstrapMethods</code> attribute </h3>
 Each <code>CONSTANT_InvokeDynamic</code> entry contains an index which references
 a bootstrap method specifier; all such specifiers are contained in a separate array.
 This array is defined by a class attribute named <code>BootstrapMethods</code>.
 The body of this attribute consists of a sequence of byte pairs, all interpreted as
 as 16-bit counts or constant pool indexes, in the <code>u2</code> format.
 The attribute body starts with a count of bootstrap method specifiers,
 which is immediately followed by the sequence of specifiers.
 <p>
 Each bootstrap method specifier contains an index to a
 <code>CONSTANT_MethodHandle</code> constant, which is the bootstrap
 method itself.
 This is followed by a count, and then a sequence (perhaps empty) of
 indexes to <a href="#args">additional static arguments</a>
 for the bootstrap method.
 <p>
 During class loading, the verifier must check the structure of the
 <code>BootstrapMethods</code> attribute.  In particular, each constant
 pool index must be of the correct type.  A bootstrap method index
 must refer to a <code>CONSTANT_MethodHandle</code> (tag 15).
 Every other index must refer to a valid operand of an
 <code>ldc_w</code> or <code>ldc2_w</code> instruction (tag 3..8 or 15..16).

 <h3><a name="args">static arguments to the bootstrap method</h3>
 An <code>invokedynamic</code> instruction specifies at least three arguments
 to pass to its bootstrap method:
 The caller class (expressed as a <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>Lookup object</code></a>,
 the name (extracted from the <code>CONSTANT_NameAndType</code> entry),
 and the type (also extracted from the <code>CONSTANT_NameAndType</code> entry).
 The <code>invokedynamic</code> instruction may specify additional metadata values
 to pass to its bootstrap method.
 Collectively, these values are called <em>static arguments</em> to the
 <code>invokedynamic</code> instruction, because they are used once at link
 time to determine the instruction's behavior on subsequent sets of
 <em>dynamic arguments</em>.
 <p>
 Static arguments are used to communicate application-specific meta-data
 to the bootstrap method.
 Drawn from the constant pool, they may include references to classes, method handles,
 strings, or numeric data that may be relevant to the task of linking that particular call site.
 <p>
 Static arguments are specified constant pool indexes stored in the <code>BootstrapMethods</code> attribute.
 Before the bootstrap method is invoked, each index is used to compute an <code>Object</code>
 reference to the indexed value in the constant pool.
 The valid constant pool entries are listed in this table:
 <code>
 <table border=1 cellpadding=5 summary="Static argument types">
 <tr><th>entry type</th><th>argument type</th><th>argument value</th></tr>
 <tr><td>CONSTANT_String</td><td><code>java.lang.String</code></td><td>the indexed string literal</td></tr>
 <tr><td>CONSTANT_Class</td><td><code>java.lang.Class</code></td><td>the indexed class, resolved</td></tr>
 <tr><td>CONSTANT_Integer</td><td><code>java.lang.Integer</code></td><td>the indexed int value</td></tr>
 <tr><td>CONSTANT_Long</td><td><code>java.lang.Long</code></td><td>the indexed long value</td></tr>
 <tr><td>CONSTANT_Float</td><td><code>java.lang.Float</code></td><td>the indexed float value</td></tr>
 <tr><td>CONSTANT_Double</td><td><code>java.lang.Double</code></td><td>the indexed double value</td></tr>
 <tr><td>CONSTANT_MethodHandle</td><td><code>java.lang.invoke.MethodHandle</code></td><td>the indexed method handle constant</td></tr>
 <tr><td>CONSTANT_MethodType</td><td><code>java.lang.invoke.MethodType</code></td><td>the indexed method type constant</td></tr>
 </table>
 </code>
 <p>
 If a given <code>invokedynamic</code> instruction specifies no static arguments,
 the instruction's bootstrap method will be invoked on three arguments,
 conveying the instruction's caller class, name, and method type.
 If the <code>invokedynamic</code> instruction specifies one or more static arguments,
 those values will be passed as additional arguments to the method handle.
 (Note that because there is a limit of 255 arguments to any method,
 at most 252 extra arguments can be supplied.)
 The bootstrap method will be invoked as if by either <code>invokeGeneric</code>
 or <code>invokeWithArguments</code>.  (There is no way to tell the difference.)
 <p>
 The normal argument conversion rules for <code>invokeGeneric</code> apply to all stacked arguments.
 For example, if a pushed value is a primitive type, it may be converted to a reference by boxing conversion.
 If the bootstrap method is a variable arity method (its modifier bit <code>0x0080</code> is set),
 then some or all of the arguments specified here may be collected into a trailing array parameter.
 (This is not a special rule, but rather a useful consequence of the interaction
 between <code>CONSTANT_MethodHandle</code> constants, the modifier bit for variable arity methods,
 and the <code>java.lang.invoke.MethodHandle#asVarargsCollector asVarargsCollector</code> transformation.)
 <p>
 Given these rules, here are examples of legal bootstrap method declarations,
 given various numbers <code>N</code> of extra arguments.
 The first rows (marked <code>*</code>) will work for any number of extra arguments.
 <code>
 <table border=1 cellpadding=5 summary="Static argument types">
 <tr><th>N</th><th>sample bootstrap method</th></tr>
 <tr><td>*</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code></td></tr>
 <tr><td>*</td><td><code>CallSite bootstrap(Object... args)</code></td></tr>
 <tr><td>*</td><td><code>CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs)</code></td></tr>
 <tr><td>0</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type)</code></td></tr>
 <tr><td>0</td><td><code>CallSite bootstrap(Lookup caller, Object... nameAndType)</code></td></tr>
 <tr><td>1</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg)</code></td></tr>
 <tr><td>2</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code></td></tr>
 <tr><td>2</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String... args)</code></td></tr>
 <tr><td>2</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y)</code></td></tr>
 </table>
 </code>
 The last example assumes that the extra arguments are of type
 <code>CONSTANT_String</code> and <code>CONSTANT_Integer</code>, respectively.
 The second-to-last example assumes that all extra arguments are of type
 <code>CONSTANT_String</code>.
 The other examples work with all types of extra arguments.
 <p>
 As noted above, the actual method type of the bootstrap method can vary.
 For example, the fourth argument could be <code>MethodHandle</code>,
 if that is the type of the corresponding constant in
 the <code>CONSTANT_InvokeDynamic</code> entry.
 In that case, the <code>invokeGeneric</code> call will pass the extra method handle
 constant as an <code>Object</code>, but the type matching machinery of <code>invokeGeneric</code>
 will cast the reference back to <code>MethodHandle</code> before invoking the bootstrap method.
 (If a string constant were passed instead, by badly generated code, that cast would then fail,
 resulting in a <code>BootstrapMethodError</code>.)
 <p>
 Extra bootstrap method arguments are intended to allow language implementors
 to safely and compactly encode metadata.
 In principle, the name and extra arguments are redundant,
 since each call site could be given its own unique bootstrap method.
 Such a practice is likely to produce large class files and constant pools.

 <h2><a name="structs"></a>Structure Summary</h2>
 <blockquote><pre>// summary of constant and attribute structures
struct CONSTANT_MethodHandle_info {
  u1 tag = 15;
  u1 reference_kind;       // 1..8 (one of REF_invokeVirtual, etc.)
  u2 reference_index;      // index to CONSTANT_Fieldref or *Methodref
}
struct CONSTANT_MethodType_info {
  u1 tag = 16;
  u2 descriptor_index;    // index to CONSTANT_Utf8, as in NameAndType
}
struct CONSTANT_InvokeDynamic_info {
  u1 tag = 18;
  u2 bootstrap_method_attr_index;  // index into BootstrapMethods_attr
  u2 name_and_type_index;          // index to CONSTANT_NameAndType, as in Methodref
}
struct BootstrapMethods_attr {
 u2 name;  // CONSTANT_Utf8 = "BootstrapMethods"
 u4 size;
 u2 bootstrap_method_count;
 struct bootstrap_method_specifier {
   u2 bootstrap_method_ref;  // index to CONSTANT_MethodHandle
   u2 bootstrap_argument_count;
   u2 bootstrap_arguments[bootstrap_argument_count];  // constant pool indexes
 } bootstrap_methods[bootstrap_method_count];
}
 </pre></blockquote></div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.7</dd></dl>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><strong>Java&trade;&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;7</strong><br><strong>DRAFT&nbsp;ea-b139</strong></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../java/lang/instrument/package-summary.html">Prev Package</a></li>
<li><a href="../../../java/lang/management/package-summary.html">Next Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?java/lang/invoke/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/7/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> <a href="../../../../legal/cpyr.html">Copyright</a> &#x00a9; 1993, 2011, Oracle and/or its affiliates.  All rights reserved. </font><br><strong>DRAFT&nbsp;ea-b139</strong></small></p>
</body>
</html>
